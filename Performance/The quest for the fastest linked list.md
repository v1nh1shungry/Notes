## 链表的性能很糟糕

### 访存方式

在现代硬件上，瓶颈通常在于内存子系统。CPU很快，但内存并不快。因此，CPU包含一个称为预取器的组件，它可以分析程序的访存规律，并在数据实际需要之前提前加载数据。

遍历链表只能跟随 next 指针，逐个节点解引用后才能知道下一个节点的位置，导致无规律的访存。此外，内存预取通常以 64 字节为单位，预取链表节点时，很可能只有一部分数据属于链表节点，传输的其他数据就都没用了。

### 指令并行度低

遍历链表的 CPU 利用率不高，因为只有处理完当前节点后才能知道下一个节点的位置。

## 内存布局

一张链表在内存中可能的三种布局：

### 随机布局

即各个节点随机地散落在内存的各个位置，是系统在长时间分配和释放节点后可能产生的布局。这种布局效率最低：节点在内存中彼此相距较远，而在遍历链表时，访问模式完全不可预测。

### 紧凑布局

节点集中存放在相近的位置，但是依旧无法预测访存规律。节点彼此靠近增加了下一个节点在预取缓存中的可能性，因而提高了性能。

### 完美布局

节点集中存放在相近的位置，并且访问顺序可预测，从而使预取器能提前加载数据。这种布局的性能最优秀。

### 影响

当链表数据量较小时，由于所有数据都能存放进缓存中，因此三种布局的性能差异不明显。当数据量非常大时，完美布局以外的两种布局性能下降非常多，并且内存传输数据量也大得多。

## 优化思路

### 非必要不遍历链表

只需要遍历部分节点时，可以使用跳过指针跳过不需要访问的节点。

### 使用自定义的内存分配器为链表分配内存

所有节点都从一个专用的内存块里分配，使内存布局更紧凑，从而提高缓存命中率。**注意：对于 `std::list` 这样的 STL 容器，同一类型的链表的所有实例都将共享同一个内存分配器，因此尽管内存布局变得紧凑，但仍然不能期望链表中的连续节点在内存中也是连续的。**

数据量较大时，为每个链表实例都配置单独的内存分配器。**然而 STL 容器不支持**。

### 使用 `std::vector` 实现

#### 实现思路

使用 `std::vector` 来存储数据，删除节点时，将节点放回空闲列表中，

> [!info] 猜测
> 文章没有细说，看下文的 `jsl::filter_vector` 应该就是用一个 `bitset` 来簿记节点使用情况。

#### 优点

* 避免了插入和删除元素频繁的分配和释放内存；
* 内存布局非常紧凑，提高缓存命中率；
* 避免内存碎片；
* 无须指针来引用下一个节点，使每个节点的尺寸更小，进一步提高了缓存命中率；
* 链表变得碎片化的时候可以进行 compact 将内存布局调整回完美布局；

#### 缺点

* `std::vector` 会占用更多内存，特别是当它进行扩容时，会消耗两倍实际需要空间；
* 如果删除了大量节点，可能导致存在许多空洞，进一步浪费内存（可以通过 compact 缓解）；
* 迭代器不稳定，但是索引是稳定的，可以转用索引来引用节点；

> [!info] 迭代器稳定性（来自 Qwen）
> 迭代器稳定性（Iterator Stability）是编程语言（尤其是C++等支持迭代器的系统级语言）中的一个重要概念，指的是在对容器进行修改操作（如插入、删除、重排等）后，已存在的迭代器是否仍然有效、可继续使用。

### 手动展开链表

即在同一个节点中储存多个值。

#### 优点

* 提高缓存命中率；
* 减少了内存分配的次数；

#### 缺点

* 可能会占用更多内存：单个节点未被填满；
* 迭代更复杂；
* 迭代器不稳定；

### `Colony`

游戏开发中经常需要一种无序集合，要求能快速插入、删除对象，也能快速遍历整个集合。

`Colony` 底层由 `std::vector` 实现，思路是内存以块的形式分配，每个块可以储存多个对象。插入对象时，没有有空余空间的块时就分配一个新的块。删除对象时，直接标记对应的位置无效即可。仅当整个块都空闲时才有可能释放内存。此外，对象在内存中的位置是固定的，这是游戏开发的需求。

`Colony` 的标准化在 `std::hive` 中。

## References

* [The quest for the fastest linked list](https://johnnysswlab.com/the-quest-for-the-fastest-linked-list/)
