> [!attention]
> 以下内容均由 Gemini 和 GLM 老师整理

## 使用 `bloaty` 进行应用程序分析

`bloaty` 是一个重要的二进制文件大小分析工具。它可以帮助你了解二进制文件中各个部分占用的空间，从而有针对性地进行优化。通过分析，你可以确定哪些部分占用空间最多，然后优先优化这些部分。

## `-fdata-sections -ffunction-sections` 和 `-Wl,-gc-sections`

通常情况下，编译器会将目标文件中所有的函数（`.text` 段）和全局/静态数据（`.data` 或 `.bss` 段）分别打包成一个大块。`-fdata-sections` 和 `-ffunction-sections` 这两个编译选项的作用是告诉编译器，为每个函数和每个全局/静态数据单独创建一个段。例如，一个名为 `foo` 的函数将拥有一个名为 `.text.foo` 的独立段。

当链接器（如 `ld` 或 `lld`）收到这些带有独立段的目标文件时，`-Wl,-gc-sections` 链接器选项会发挥作用。链接器会进行**静态分析**，识别出程序中所有未被引用的函数和数据段。这些未被引用的段会被链接器从最终的二进制文件中移除。这项技术可以显著减小 `.text` 和 `.data` 段的大小，特别是对于使用了大型库但只用到了其中一小部分功能的应用程序。

## `-Wl,-icf=safe` 或 `-Wl,-icf=all`

**ICF** 是链接器的一项优化技术，其全称为 **Identical Code Folding**（或 **Identical Function Folding**）。它通过在链接时识别并合并程序中完全相同的代码序列或函数来实现大小减小。

当代码中存在多个完全相同的模板实例化、内联函数、或者由于编译器优化（如某些常量传播或死代码消除）而产生的重复代码块时，ICF 就能发挥作用。链接器会找到这些重复的指令序列，只保留一份副本，然后将所有引用都重定向到这个唯一的副本上。

`icf=safe` 选项只会合并那些被认为“安全”的代码，即不会导致任何意外行为的代码。而 `icf=all` 选项则更加激进，可能会合并一些可能导致标准不兼容行为的代码，例如那些依赖于函数地址唯一性的代码（尽管这在 C++ 标准中通常是不允许的）。因此，`icf=all` 可能会带来更大的空间收益，但风险更高。

## `-fvisibility=hidden`

在默认情况下，GCC 和 Clang 编译器会为所有函数和全局变量使用 `default` 可见性。这意味着这些符号可以在链接时被其他共享库或可执行文件访问。为了实现这种可见性，编译器和链接器需要在最终的二进制文件中保留这些符号的名称、类型和地址等信息，这些信息存储在 **`.strtab` (字符串表)** 和 **`.symtab` (符号表)** 等节中。

`fvisibility=hidden` 编译选项会改变这种默认行为。它告诉编译器，除非被显式标记（例如，使用 `__attribute__((visibility("default")))`），否则所有符号都应具有 `hidden` 可见性。`hidden` 可见性意味着该符号无法被其他模块访问。

对于一个静态链接的自包含应用来说，由于它不需要向外部提供任何接口，因此将所有符号都设置为 `hidden` 是一个非常有效的减小二进制文件大小的手段。它极大地减少了 `.strtab` 和 `.symtab` 的大小，因为链接器不需要为外部访问保留这些符号信息。

## `-fvisibility-inline-hidden`

这是 `-fvisibility=hidden` 的精细化版本，专门针对内联函数：
- 只将内联函数的可见性设为 `hidden`
- 保持其他函数的默认可见性

内联函数通常在头文件中定义，可能在多个翻译单元中实例化。通过隐藏这些内联函数，可以避免它们在动态符号表中出现，同时不影响需要导出的其他函数的可见性，是一种折衷的优化方案。

## `-Wl,--pack-dyn-relocs=relr`

**重定位（Relocation）** 是链接器和动态加载器的关键部分。在构建可执行文件时，链接器会生成一张**重定位表**（如 `.rela.dyn`），其中记录了所有需要在程序加载到内存时进行地址修正的位置，例如对共享库函数或全局变量的引用。当动态加载器将可执行文件和它依赖的共享库加载到内存时，它会遍历这张表，用实际的运行时地址来修正这些引用。

`--pack-dyn-relocs=relr` 链接器选项利用了 **`RELR` (Relative Relocation)** 格式来优化这个过程。`RELR` 是一种新的、更紧凑的重定位格式，它基于**相对地址**。

具体来说，`RELR` 格式通过记录相对于前一个重定位项的偏移量来存储地址，而不是像传统的 `RELA` 格式那样存储完整的绝对地址。这种相对存储方式在地址空间连续的情况下，可以极大地压缩重定位信息。特别是对于那些拥有大量重定位项的二进制文件，`--pack-dyn-relocs=relr` 可以显著减小 `.rela.dyn` 节的大小。

## Machine-outliner

**Machine-outlining** 是一项编译器优化技术，其目标是在程序中识别重复的、小的代码序列，并将其提取（"outline"）成一个新的、独立的函数。然后，原始位置的代码将被替换为对这个新函数的调用。

这项技术的思想类似于 **ICF**，但它是在更细粒度的指令层面工作，并且可以处理不是完全相同的代码序列（通过参数化）。然而，**outlining** 也会引入新的开销：每次调用这个新提取的函数都需要额外的指令（如 `bl` 或 `call` 指令）和返回指令 (`ret`)，这可能会增加指令缓存的压力，并引入额外的函数调用开销，从而导致性能下降。作者提到的性能下降就是这种开销的体现。

## `-fexperimental-relative-c++-abi-vtables` 和 `-fexperimental-omit-vtable-rtti`

- **相对虚表 (Relative V-tables)**：在 C++ 中，**虚表 (V-table)** 包含指向虚函数的指针。通常，这些指针是绝对地址。`relative-c++-abi-vtables` 选项会尝试使用**相对偏移量**来存储这些指针。这可以减小虚表的大小，特别是当虚表有很多条目时，因为相对偏移量通常比绝对地址短。

- **忽略虚表中的 RTTI (RTTI-less V-tables)**：**RTTI** (Run-Time Type Information) 是一种允许在运行时获取对象类型信息的机制。为了支持 RTTI，虚表通常包含一个指向 `type_info` 对象的指针。`omit-vtable-rtti` 选项会从虚表中移除这个指针，从而减小虚表的大小。如果应用程序不使用 `dynamic_cast` 或 `typeid`，这个优化是安全的。

## GVN Sink/Hoist

**编译器技术：全局值编号与代码重排**

GVN(Global Value Numbering) 是一种中间代码优化技术：
- 为每个计算的表达式分配唯一的值编号
- 使用这些编号识别相同的表达式
- 基于此执行各种优化，如冗余计算消除和常量传播

Sink 和 Hoist 是GVN的扩展优化：
- GVN Hoist：将计算提升到循环或其他控制结构之外，减少重复计算
- GVN Sink：将计算下沉到真正需要结果的地方，避免在不必要路径上执行

这些优化可以间接影响代码大小，例如通过消除冗余代码或为其他优化(如死代码消除)创造条件。

## References

* [State of the art for reducing executable size with heavily optimized program](https://discourse.llvm.org/t/state-of-the-art-for-reducing-executable-size-with-heavily-optimized-program/87952)
